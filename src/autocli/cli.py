import argparse
import subprocess
import sys
import logging
import pathlib


logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)8s "
    "%(module)s:%(funcName)s:%(lineno)s | %(message)s",
)
log = logging.getLogger(__file__)


class CLIGenerator:
    _build_dir: pathlib.Path
    _auto_dir: pathlib.Path

    def __init__(self):
        parser = self._get_parser()
        args = parser.parse_args()

        self.name: str = args.name
        self.specification: str = args.specification

        self._ensure_directories(args)
        self._pull_container()
        self._run_container()

    def _get_parser(self) -> argparse.ArgumentParser:
        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        )
        parser.add_argument(
            "name",
            help="name of the project (preferably with '-cli' suffix)",
        )
        parser.add_argument(
            "specification",
            help="URL pointing to the JSON OpenAPI specification",
        )
        parser.add_argument(
            "--build-dir",
            required=False,
            help="path to build directory",
            default="./build/{name}",
        )
        parser.add_argument(
            "-f",
            "--force",
            help="overwrite the previous autogenerated data",
            action="store_true",
        )
        return parser

    def _ensure_directories(self, args: argparse.Namespace) -> None:
        # Create build directory for the project
        self.build_dir: pathlib.Path = (
            pathlib.Path(args.build_dir.format(name=self.name))
            if "{name}" in args.build_dir
            else pathlib.Path(args.build_dir)
        )
        log.debug(f"ensuring directory {self.build_dir!s}")
        self.build_dir.mkdir(exist_ok=True)

        # Create build directory for autogenerated code
        self.auto_dir = self.build_dir / "auto"
        if self.auto_dir.is_dir() and not args.force:
            log.critical(f"directory {self.auto_dir!s} already exists")
            sys.exit(1)
        log.debug(f"ensuring directory {self.auto_dir!s}")
        self.auto_dir.mkdir(exist_ok=True)

    def _pull_container(self) -> None:
        log.info("fetching container image")
        cmd_fetch: subprocess.CompletedProcess = subprocess.run(
            ["podman", "pull", "docker.io/swaggerapi/swagger-codegen-cli"],
            capture_output=True,
        )
        if cmd_fetch.returncode != 0:
            log.critical(
                "could not pull container image\n"
                + "stdout:\n"
                + cmd_fetch.stdout.decode("utf-8")
                + "stderr:\n"
                + cmd_fetch.stderr.decode("utf-8")
            )
            sys.exit(1)

    def _run_container(self) -> None:
        log.info("generating the library from API specification")
        cmd_gen: subprocess.CompletedProcess = subprocess.run(
            [
                "podman",
                "run",
                "--rm",
                "-v",
                f"./{self.auto_dir!s}:/local/out/py",
                "swaggerapi/swagger-codegen-cli:latest",
                "generate",
                "-i",
                self.specification,
                "-l",
                "python",
                "-o",
                "/local/out/py",
            ],
            capture_output=True,
        )
        if cmd_gen.returncode != 0:
            log.critical(
                "could not generate the library\n"
                + "stdout:\n"
                + cmd_gen.stdout.decode("utf-8")
                + "stderr:\n"
                + cmd_gen.stderr.decode("utf-8")
            )
            sys.exit(1)


def main():
    g = CLIGenerator()
    print(g)


if __name__ == "__main__":
    main()
